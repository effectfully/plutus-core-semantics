define @PlutusInternal.closure.new(%func, %arity, %boundArgs) {
  %spaceNeeded = add 3, %boundArgs
  %ret = call @alloc(%spaceNeeded)
  %writePtr = %ret                 store %func     , %writePtr
  %writePtr = add %writePtr, 1     store %arity    , %writePtr
  %writePtr = add %writePtr, 1     store %boundArgs, %writePtr
  ret %ret
}
define @PlutusInternal.closure.func(%closure) {
  %ret = load %closure ret %ret
}
define @PlutusInternal.closure.arity(%closure) {
  %ptr = add %closure, 1
  %ret = load %ptr
  ret %ret
}
define @PlutusInternal.closure.bound(%closure) {
  %ptr = add %closure, 2
  %ret = load %ptr
  ret %ret
}
// 1-based
define @PlutusInternal.closure.nthArg(%closure, %n) {
  %ptr = add %closure, 2
  %ptr = add %ptr, %n
  %ret = load %ptr
  ret %ret
}
define @PlutusInternal.closure.nthArg.set(%closure, %n, %val) {
  %ptr = add %closure, 2
  %ptr = add %ptr, %n
  store %val, %ptr
  ret void
}

define public @PlutusTest.closure() {
  %testNum = 1
  %cl = call @PlutusInternal.closure.new(123, 5, 2)

  %testNum = 2
  %actual = call @PlutusInternal.closure.func(%cl)
  %testResult = cmp ne %actual, 123
  br %testResult, invalid
 
  %testNum = 3
  %actual = call @PlutusInternal.closure.arity(%cl)
  %testResult = cmp ne %actual, 5
  br %testResult, invalid

  %testNum = 4
  %actual = call @PlutusInternal.closure.bound(%cl)
  %testResult = cmp ne %actual, 2
  br %testResult, invalid

  %testNum = 5
  %nextAlloc = call @alloc(1)
  %actual = sub %nextAlloc, %cl
  %testResult = cmp ne %actual, 5
  br %testResult, invalid

  %testNum = 7
  %actual = call @PlutusInternal.closure.nthArg(%cl, 2)
  %testResult = cmp ne %actual, 0
  br %testResult, invalid

  %testNum = 8
            call @PlutusInternal.closure.nthArg.set(%cl, 2, 2222)
  %actual = call @PlutusInternal.closure.nthArg    (%cl, 2)
  %testResult = cmp ne %actual, 2222
  br %testResult, invalid

  %testNum = 9
  %cl1 = call @appendArg(%cl, 3333)
  %actual = call @PlutusInternal.closure.nthArg(%cl1, 3)
  %testResult = cmp ne %actual, 3333
  br %testResult, invalid

  %testNum = 10
  %actual = call @PlutusInternal.closure.nthArg(%cl1, 2)
  %testResult = cmp ne %actual, 2222
  br %testResult, invalid

  ret 0
invalid:
  ret %testNum, %actual
}

define @PlutusInternal.dispatch ( %closure , %param ) {
  %func = load %closure
  %readPtr = add %closure , 1
  %arity = load %readPtr
  %readPtr = add %readPtr , 1
  %numParams = load %readPtr

  %numParamsPlus1 = add %numParams , 1
  %notEnoughParams = cmp ne %numParamsPlus1 , %arity
  br %notEnoughParams , notEnoughParams
  %haveEnough1 = cmp eq 1 , %arity
  br %haveEnough1 , haveEnough1
  %haveEnough2 = cmp eq 2 , %arity
  br %haveEnough2 , haveEnough2
  %haveEnough3 = cmp eq 3 , %arity
  br %haveEnough3 , haveEnough3

notEnoughParams:
  %ret = call @appendArg ( %closure , %param )
  ret %ret

haveEnough1:
  %ret = call %func ( %param )
  ret %ret

haveEnough2:
  %ret = call @PlutusInternal.unfoldClosure2 ( %closure , %param )
  ret %ret

haveEnough3:
  %ret = call @PlutusInternal.unfoldClosure3 ( %closure , %param )
  ret %ret
}

define @PlutusInternal.unfoldClosure2 ( %closure , %param ) {
  %func = load %closure
  %readPtr = add %closure , 2
  %readPtr = add %readPtr , 1
  %param1 = load %readPtr
  %ret = call %func ( %param1 , %param )
  ret %ret
}

define @PlutusInternal.unfoldClosure3 ( %closure , %param ) {
  %func = load %closure
  %readPtr = add %closure , 2
  %readPtr = add %readPtr , 1
  %param1 = load %readPtr
  %readPtr = add %readPtr , 1
  %param2 = load %readPtr
  %ret = call %func ( %param1 , %param2 , %param )
  ret %ret
}

define @PlutusInternal.unfoldClosure4 ( %closure , %param ) {
  %func = load %closure
  %readPtr = add %closure , 2
  %readPtr = add %readPtr , 1
  %param1 = load %readPtr
  %readPtr = add %readPtr , 1
  %param2 = load %readPtr
  %readPtr = add %readPtr , 1
  %param3 = load %readPtr
  %ret = call %func ( %param1 , %param2 , %param3 , %param )
  ret %ret
}

define @alloc ( %size ) {
  %isZero = cmp eq %size , 0
  br %isZero , allocZero
  %alloc_counter_ptr = 0
  %alloced = load %alloc_counter_ptr
  %isInitialized = cmp ne 0 , %alloced
  br %isInitialized , initialized
  %alloced = 1

  initialized:
  %ret = %alloced
  %alloced = add %size , %alloced
  store %alloced , %alloc_counter_ptr
  ret %ret

  allocZero:
  ret 0
}

define @appendArg ( %closure , %param ) {
  %func = call @PlutusInternal.closure.func(%closure)
  %arity = call @PlutusInternal.closure.arity(%closure)
  %boundOld = call @PlutusInternal.closure.bound(%closure)
  %boundNew = add %boundOld , 1

  %ret = call @PlutusInternal.closure.new(%func, %arity, %boundNew)

  %n = 0
while:
  %cond = cmp eq %boundOld , %n
  %n = add %n, 1
  br %cond , done
  %paramN = call @PlutusInternal.closure.nthArg(%closure, %n)
  call @PlutusInternal.closure.nthArg.set(%ret, %n, %paramN)
  br while
done:
  call @PlutusInternal.closure.nthArg.set(%ret, %n, %param)
  ret %ret
}
