define @PlutusInternal.closure.new(%func, %arity, %boundArgs) {
  %spaceNeeded = add 3, %boundArgs
  %ret = call @alloc(%spaceNeeded)
  %writePtr = %ret                 store %func     , %writePtr
  %writePtr = add %writePtr, 1     store %arity    , %writePtr
  %writePtr = add %writePtr, 1     store %boundArgs, %writePtr
  ret %ret
}
define @PlutusInternal.closure.func(%closure) {
  %ret = load %closure ret %ret
}
define @PlutusInternal.closure.arity(%closure) {
  %ptr = add %closure, 1
  %ret = load %ptr
  ret %ret
}
define @PlutusInternal.closure.bound(%closure) {
  %ptr = add %closure, 2
  %ret = load %ptr
  ret %ret
}
// 1-based
define @PlutusInternal.closure.nthArg(%closure, %n) {
  %ptr = add %closure, 2
  %ptr = add %ptr, %n
  %ret = load %ptr
  ret %ret
}
define @PlutusInternal.closure.nthArg.set(%closure, %n, %val) {
  %ptr = add %closure, 2
  %ptr = add %ptr, %n
  store %val, %ptr
  ret void
}

define @PlutusTest.third(%one, %two, %three, %four, %five) {
  ret %three
}

define public @PlutusTest.closure() {
// Creating a new closure
// ----------------------

  %testNum = 1
  %cl = call @PlutusInternal.closure.new(@PlutusTest.third, 5, 2)

  %testNum = 2
  %actual = call @PlutusInternal.closure.func(%cl)
  %testResult = cmp ne %actual, @PlutusTest.third
  br %testResult, invalid
 
  %testNum = 3
  %actual = call @PlutusInternal.closure.arity(%cl)
  %testResult = cmp ne %actual, 5
  br %testResult, invalid

  %testNum = 4
  %actual = call @PlutusInternal.closure.bound(%cl)
  %testResult = cmp ne %actual, 2
  br %testResult, invalid

  %testNum = 5
  %nextAlloc = call @alloc(1)
  %actual = sub %nextAlloc, %cl
  %testResult = cmp ne %actual, 5
  br %testResult, invalid

// Accessing and setting arguments
// -------------------------------

  %testNum = 7
  %actual = call @PlutusInternal.closure.nthArg(%cl, 2)
  %testResult = cmp ne %actual, 0
  br %testResult, invalid

  %testNum = 8
            call @PlutusInternal.closure.nthArg.set(%cl, 2, 2222)
  %actual = call @PlutusInternal.closure.nthArg    (%cl, 2)
  %testResult = cmp ne %actual, 2222
  br %testResult, invalid

// Appending Arguments
// -------------------

  %testNum = 9
  %cl1 = call @appendArg(%cl, 3333)
  %actual = call @PlutusInternal.closure.func(%cl1)
  %testResult = cmp ne %actual, @PlutusTest.third
  br %testResult, invalid

  %testNum = 10
  %actual = call @PlutusInternal.closure.nthArg(%cl1, 2)
  %testResult = cmp ne %actual, 2222
  br %testResult, invalid

  %testNum = 11
  %actual = call @PlutusInternal.closure.nthArg(%cl1, 3)
  %testResult = cmp ne %actual, 3333
  br %testResult, invalid

  %testNum = 12
  %actual = call @PlutusInternal.closure.bound(%cl1)
  %testResult = cmp ne %actual, 3
  br %testResult, invalid

  %testNum = 13
  %actual = call @PlutusInternal.closure.arity(%cl1)
  %testResult = cmp ne %actual, 5
  br %testResult, invalid

// Dispatch
// --------

  %testNum = 14
  %cl2 = call @PlutusInternal.dispatch(%cl1, 4444)
  %actual = call @PlutusInternal.closure.bound(%cl2)
  %testResult = cmp ne %actual, 4
  br %testResult, invalid

  %testNum = 15
  %actual = call @PlutusInternal.closure.arity(%cl2)
  %testResult = cmp ne %actual, 5
  br %testResult, invalid

  %testNum = 16
  %actual = call @PlutusInternal.dispatch(%cl2)
  %testResult = cmp ne %actual, 3333
  br %testResult, invalid

  ret 0
invalid:
  ret %testNum, %actual
}

define @PlutusInternal.dispatch ( %closure , %param ) {
  %func = load %closure
  %readPtr = add %closure , 1
  %arity = load %readPtr
  %readPtr = add %readPtr , 1
  %numParams = load %readPtr

  %numParamsPlus1 = add %numParams , 1
  %notEnoughParams = cmp ne %numParamsPlus1 , %arity
  br %notEnoughParams , notEnoughParams
  %haveEnough1 = cmp eq 1 , %arity
  br %haveEnough1 , haveEnough1
  %haveEnough2 = cmp eq 2 , %arity
  br %haveEnough2 , haveEnough2
  %haveEnough3 = cmp eq 3 , %arity
  br %haveEnough3 , haveEnough3
  %haveEnough4 = cmp eq 4 , %arity
  br %haveEnough4 , haveEnough4
  %haveEnough5 = cmp eq 5 , %arity
  br %haveEnough5 , haveEnough5

  call @iele.invalid()

notEnoughParams:
  %ret = call @appendArg ( %closure , %param )
  ret %ret

haveEnough1:
  %ret = call %func ( %param )
  ret %ret
haveEnough2:
  %ret = call @PlutusInternal.unfoldClosure2 ( %closure , %param )
  ret %ret
haveEnough3:
  %ret = call @PlutusInternal.unfoldClosure3 ( %closure , %param )
  ret %ret
haveEnough4:
  %ret = call @PlutusInternal.unfoldClosure4 ( %closure , %param )
  ret %ret
haveEnough5:
  %ret = call @PlutusInternal.unfoldClosure5 ( %closure , %param )
  ret %ret
}

define @PlutusInternal.unfoldClosure2 ( %closure , %param ) {
  %func   = call @PlutusInternal.closure.func(%closure)
  %param1 = call @PlutusInternal.closure.nthArg(%closure, 1)
  %ret = call %func ( %param1 , %param )
  ret %ret
}

define @PlutusInternal.unfoldClosure3 ( %closure , %param ) {
  %func   = call @PlutusInternal.closure.func(%closure)
  %param1 = call @PlutusInternal.closure.nthArg(%closure, 1)
  %param2 = call @PlutusInternal.closure.nthArg(%closure, 2)
  %ret = call %func ( %param1 , %param2 , %param )
  ret %ret
}

define @PlutusInternal.unfoldClosure4 ( %closure , %param ) {
  %func   = call @PlutusInternal.closure.func(%closure)
  %param1 = call @PlutusInternal.closure.nthArg(%closure, 1)
  %param2 = call @PlutusInternal.closure.nthArg(%closure, 2)
  %param3 = call @PlutusInternal.closure.nthArg(%closure, 3)
  %ret = call %func ( %param1 , %param2 , %param3 , %param )
  ret %ret
}

define @PlutusInternal.unfoldClosure5 ( %closure , %param ) {
  %func   = call @PlutusInternal.closure.func(%closure)
  %param1 = call @PlutusInternal.closure.nthArg(%closure, 1)
  %param2 = call @PlutusInternal.closure.nthArg(%closure, 2)
  %param3 = call @PlutusInternal.closure.nthArg(%closure, 3)
  %param4 = call @PlutusInternal.closure.nthArg(%closure, 4)
  %ret = call %func ( %param1 , %param2 , %param3, %param4 , %param )
  ret %ret
}

define @alloc ( %size ) {
  %isZero = cmp eq %size , 0
  br %isZero , allocZero
  %alloc_counter_ptr = 0
  %alloced = load %alloc_counter_ptr
  %isInitialized = cmp ne 0 , %alloced
  br %isInitialized , initialized
  %alloced = 1

  initialized:
  %ret = %alloced
  %alloced = add %size , %alloced
  store %alloced , %alloc_counter_ptr
  ret %ret

  allocZero:
  ret 0
}

define @appendArg ( %closure , %param ) {
  %func = call @PlutusInternal.closure.func(%closure)
  %arity = call @PlutusInternal.closure.arity(%closure)
  %boundOld = call @PlutusInternal.closure.bound(%closure)
  %boundNew = add %boundOld , 1

  %ret = call @PlutusInternal.closure.new(%func, %arity, %boundNew)

  %n = 0
while:
  %cond = cmp eq %boundOld , %n
  %n = add %n, 1
  br %cond , done
  %paramN = call @PlutusInternal.closure.nthArg(%closure, %n)
  call @PlutusInternal.closure.nthArg.set(%ret, %n, %paramN)
  br while
done:
  call @PlutusInternal.closure.nthArg.set(%ret, %n, %param)
  ret %ret
}
