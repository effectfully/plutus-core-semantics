(program

  (module SimpleCase (import) (export () (boolean nonExhaustive fooBarOrKungFu testMyNat testPair secondArg))

    // Bool comparison ops are capatable with Prelude.True Prelude.False
    // -----------------------------------------------------------------

    (declare boolean (fun (integer) (integer)))
    (define boolean
      (lam x
        (case (builtin equalsInteger x 13)
          (Prelude.True  () 19)
          (Prelude.False () 23))))

    // Non exhaustive case matching should fail
    // ----------------------------------------

    (declare nonExhaustive (fun (integer) (integer)))
    (define nonExhaustive
      (lam x
        (case (builtin equalsInteger x 13)
          (Prelude.True  () 19))))

    // Nullary Constructors
    // --------------------

    (data Foo () (Kung) (Bar))

    (declare fooToInt (fun (con SimpleCase.Foo) (integer)))
    (define fooToInt
      (lam x
        (case x
          (SimpleCase.Bar  () 7)
          (SimpleCase.Kung () 11))))

    (declare intToFoo (fun (integer) (con SimpleCase.Foo)))
    (define intToFoo
      (lam x
        (case (builtin equalsInteger 3 x)
          (Prelude.True  () (con SimpleCase.Bar))
          (Prelude.False () (con SimpleCase.Kung)))))

    (declare fooBarOrKungFu (fun (integer) (integer)))
    (define fooBarOrKungFu
      (lam x [ SimpleCase.fooToInt [ SimpleCase.intToFoo x]]))

    // Binary Constructors
    // -------------------

    (data MyPair () (MyMkPair (integer) (integer)))

    (declare secondArg (fun (integer) (fun (integer) (integer))))
    (define secondArg
      (lam x (lam y [SimpleCase.myFst (con SimpleCase.MyMkPair y x)])))

    (declare myFst (fun (con SimpleCase.MyPair) (integer)))
    (define myFst
      (lam p
        (case p
          (SimpleCase.MyMkPair (x y) x))))

    (declare mySwap (fun (con SimpleCase.MyPair) (con SimpleCase.MyPair)))
    (define mySwap
      (lam p
        (case p
          (SimpleCase.MyMkPair (x y) (con SimpleCase.MyMkPair y x)))))

    (declare mySnd (fun (con SimpleCase.MyPair) (integer)))
    (define mySnd
      (lam p [SimpleCase.myFst [SimpleCase.mySwap p]]))

    (declare testPair (fun (integer) (integer)))
    (define testPair
      (lam x [SimpleCase.mySnd (con SimpleCase.MyMkPair x (builtin multiplyInteger x 2))]))

    // Recursive Constructors
    // ----------------------

    (data MyNat () (Zero) (Succ (con CaseSimple.MyNat)))

    // Map MyNats on to the negative intgers

    (declare myNatToInt (fun (con SimpleCase.MyNat) (integer)))
    (define  myNatToInt
      (lam x (case x
        (SimpleCase.Zero () 0)
        (SimpleCase.Succ (y) (builtin subtractInteger [SimpleCase.myNatToInt y] 1)))))

    // NegNat |-> 0; PosNat |-> 2*MyNat

    (declare intToMyNat (fun (integer) (con SimpleCase.Foo)))
    (define intToMyNat
      (lam x
        (case (builtin lessThanEqualsInteger x 0)
          (Prelude.True  () (con SimpleCase.Zero))
          (Prelude.False () (con SimpleCase.Succ (con SimpleCase.Succ [SimpleCase.intToMyNat (builtin subtractInteger x 1)]))))))

    (declare testMyNat (fun (integer) (integer)))
    (define testMyNat
      (lam x [ SimpleCase.myNatToInt [ SimpleCase.intToMyNat x]]))
  )

)
