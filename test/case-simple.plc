(program

  (module SimpleCase (import) (export () (boolean nonExhaustive fooBarOrKungFu testMyNat))

    (declare boolean (fun (integer) (integer)))
    (define boolean
      (lam x
        (case (builtin equalsInteger x 13)
          (Prelude.True  () 19)
          (Prelude.False () 23))))

    (declare nonExhaustive (fun (integer) (integer)))
    (define nonExhaustive
      (lam x
        (case (builtin equalsInteger x 13)
          (Prelude.True  () 19))))

    (data Foo () (Kung) (Bar))

    (declare fooToInt (fun (con SimpleCase.Foo) (integer)))
    (define fooToInt
      (lam x
        (case x
          (SimpleCase.Bar  () 7)
          (SimpleCase.Kung () 11))))

    (declare intToFoo (fun (integer) (con SimpleCase.Foo)))
    (define intToFoo
      (lam x
        (case (builtin equalsInteger 3 x)
          (Prelude.True  () (con SimpleCase.Bar))
          (Prelude.False () (con SimpleCase.Kung)))))

    (declare fooBarOrKungFu (fun (integer) (integer)))
    (define fooBarOrKungFu
      (lam x [ SimpleCase.fooToInt [ SimpleCase.intToFoo x]]))

    // MyNat is a datatype with a constructor taking in an argument

    (data MyNat () (Zero) (Succ (con CaseSimple.MyNat)))

    // (declare myNatToInt (fun (con SimpleCase.MyNat) (integer)))
    // (define myNatToInt
    //   (lam x
    //     (case x
    //       (SimpleCase.Zero ()  53)
    //       (SimpleCase.Succ (y) 12))))

    // (declare intToMyNat (fun (integer) (con SimpleCase.Foo)))
    // (define intToMyNat
    //   (lam x
    //     (case (builtin equalsInteger 7 x)
    //       (Prelude.True  () (con SimpleCase.Zero))
    //       (Prelude.False () (con SimpleCase.Succ (con SimpleCase.Zero))))))

    // (declare testMyNat (fun (integer) (integer)))
    // (define testMyNat
    //   (lam x [ SimpleCase.myNatToInt [ SimpleCase.intToMyNat x]]))

  )

)
