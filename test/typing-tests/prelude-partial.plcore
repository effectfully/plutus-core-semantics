(module Prelude
    (imported)
    (exported () ())
    (local () ())


    //
    // Function Tools
    //
    
    (declare id (forall a (type) (fun a a)))
    (define id
      (abs a (lam x x)))
    
    
    (declare const
      (forall a (type) (forall b (type)
        (fun a (fun b a)))))
    (define const
      (abs a (abs b
        (lam x (lam y x)))))
    
    
    (declare flip
      (forall a (type) (forall b (type) (forall c (type)
        (fun (fun a (fun b c))
             (fun b (fun a c)))))))
    (define flip
      (abs a (abs b (abs c
        (lam f (lam x (lam y
          [f y x])))))))
    
    
    (declare applyTo
      (forall a (type) (forall b (type)
        (fun a (fun (fun a b) b)))))
    (define applyTo
      (abs a (abs b
        (lam x (lam f
          [f x])))))
    
    
    (declare compose
      (forall a (type) (forall b (type) (forall c (type)
        (fun (fun b c)
             (fun (fun a b)
                  (fun a c)))))))
    (define compose
      (abs a (abs b (abs c
        (lam f (lam g (lam x
          [f [g x]])))))))
    
    
    (declare compose2
      (forall a (type) (forall b (type) (forall c (type) (forall d (type)
        (fun (fun c d)
             (fun (fun a (fun b c))
                  (fun a (fun b d)))))))))
    (define compose2
      (abs a (abs b (abs c (abs d
        (lam f (lam g (lam x (lam y
          [f [g x y]])))))))))
    
    
    
    //
    // Unit Tools
    //
    
    (data Unit () (MkUnit))
    
    
    
    //
    // Pair Tools
    //
    
    (data Pair ((a (type)) (b (type)))
          (MkPair a b))
    
    
    (declare fst
      (forall a (type) (forall b (type)
        (fun (con Prelude.Pair a b) a))))
    (define fst
      (abs a (abs b
        (lam p
          (case p
            (Prelude.MkPair (x y) x))))))
    
    
    (declare snd
      (forall a (type) (forall b (type)
        (fun (con Prelude.Pair a b) b))))
    (define snd
      (abs a (abs b
        (lam p
          (case p
            (Prelude.MkPair (x y) y))))))
    
    
    (declare curry
      (forall a (type) (forall b (type) (forall c (type)
        (fun (fun (con Prelude.Pair a b) c)
             (fun a (fun b c)))))))
    (define curry
      (abs a (abs b (abs c
        (lam f (lam x (lam y
          [f (con Prelude.MkPair x y)])))))))
    
    
    (declare uncurry
      (forall a (type) (forall b (type) (forall c (type)
        (fun (fun a (fun b c))
             (fun (con Prelude.Pair a b) c))))))
    (define uncurry
      (abs a (abs b (abs c
        (lam f (lam p
          (case p
            (Prelude.MkPair (x y) [f x y]))))))))
    
    
    (declare swap
      (forall a (type) (forall b (type)
        (fun (con Prelude.Pair a b)
             (con Prelude.Pair b a)))))
    (define swap
      (abs a (abs b
        (lam p
          (case p
            (Prelude.MkPair (x y)
              (isa (con Prelude.MkPair y x)
                   (con Prelude.Pair b a))))))))
    
    
    
    //
    // Boolean Tools
    //
    
    (data Bool () (True) (False))
    
    
    (declare not
      (fun (con Prelude.Bool) (con Prelude.Bool)))
    (define not
      (lam x
        (case x
          (Prelude.True ()
            (isa (con Prelude.False)
                 (con Prelude.Bool)))
          (Prelude.False ()
            (isa (con Prelude.True)
                 (con Prelude.Bool))))))
    
    
    (declare and
      (fun (con Prelude.Bool)
           (fun (con Prelude.Bool)
                (con Prelude.Bool))))
    (define and
      (lam x (lam y
        (case x
          (Prelude.True () y)
          (Prelude.False ()
            (isa (con Prelude.False)
                 (con Prelude.Bool)))))))
    
    
    (declare or
      (fun (con Prelude.Bool)
           (fun (con Prelude.Bool)
                (con Prelude.Bool))))
    (define or
      (lam x (lam y
        (case x
          (Prelude.True ()
            (isa (con Prelude.True)
                 (con Prelude.Bool)))
          (Prelude.False () x)))))
    
    
    (declare bool
      (forall a (type)
        (fun a (fun a (fun (con Prelude.Bool) a)))))
    (define bool
      (abs a
        (lam f (lam t (lam b
          (case b
            (Prelude.True  () t)
            (Prelude.False () f)))))))
    
    
    
    //
    // Integer Tools
    //
    
    (declare addInteger
      (fun (integer) (fun (integer) (integer))))
    (define addInteger
      (lam x (lam y
        (builtin addInteger x y))))
    
    
    (declare subtractInteger
      (fun (integer) (fun (integer) (integer))))
    (define subtractInteger
      (lam x (lam y
        (builtin subtractInteger x y))))
    
    
    (declare multiplyInteger
      (fun (integer) (fun (integer) (integer))))
    (define multiplyInteger
      (lam x (lam y
        (builtin multiplyInteger x y))))
    
    
    (declare divideInteger
      (fun (integer) (fun (integer) (integer))))
    (define divideInteger
      (lam x (lam y
        (builtin divideInteger x y))))
    
    
    (declare remainderInteger
      (fun (integer) (fun (integer) (integer))))
    (define remainderInteger
      (lam x (lam y
        (builtin remainderInteger x y))))
    
    
    (declare equalsInteger
      (fun (integer) (fun (integer) (con Prelude.Bool))))
    (define equalsInteger
      (lam x (lam y
        (builtin equalsInteger x y))))
    
    
    (declare lessThanInteger
      (fun (integer) (fun (integer) (con Prelude.Bool))))
    (define lessThanInteger
      (lam x (lam y
        (builtin lessThanInteger x y))))
    
    
    (declare lessThanEqualsInteger
      (fun (integer) (fun (integer) (con Prelude.Bool))))
    (define lessThanEqualsInteger
      (lam x (lam y
        (builtin lessThanEqualsInteger y x))))
    
    
    (declare maxInteger
      (fun (integer) (fun (integer) (integer))))
    (define maxInteger
      (lam x (lam y
        (case [Prelude.lessThanInteger x y]
          (Prelude.True () y)
          (Prelude.False () x)))))
    
    
    (declare minInteger
      (fun (integer) (fun (integer) (integer))))
    (define minInteger
      (lam x (lam y
        (case [Prelude.lessThanInteger x y]
          (Prelude.True () x)
          (Prelude.False () y)))))
    
    
    // (declare integerToFloat
    //   (fun (integer) (float)))
    // (define integerToFloat
    //   (lam x
    //     (builtin integerToFloat x)))
    
    
    (declare integerToByteString
      (fun (integer) (bytestring)))
    (define integerToByteString
      (lam x
        (builtin integerToByteString x)))
    
    
    
    //
    // Float Tools
    //
    
    // (declare addFloat
    //   (fun (float) (fun (float) (float))))
    // (define addFloat
    //   (lam x (lam y
    //     (builtin addFloat x y))))
    
    
    // (declare subtractFloat
    //   (fun (float) (fun (float) (float))))
    // (define subtractFloat
    //   (lam x (lam y
    //     (builtin subtractFloat x y))))
    
    
    // (declare multiplyFloat
    //   (fun (float) (fun (float) (float))))
    // (define multiplyFloat
    //   (lam x (lam y
    //     (builtin multiplyFloat x y))))
    
    
    // (declare divideFloat
    //   (fun (float) (fun (float) (float))))
    // (define divideFloat
    //   (lam x (lam y
    //     (builtin divideFloat x y))))
    
    
    // (declare equalsFloat
    //   (fun (float) (fun (float) (con Prelude.Bool))))
    // (define equalsFloat
    //   (lam x (lam y
    //     (builtin equalsFloat x y))))
    
    
    // (declare lessThanFloat
    //   (fun (float) (fun (float) (con Prelude.Bool))))
    // (define lessThanFloat
    //   (lam x (lam y
    //     (builtin lessThanFloat x y))))
    
    
    // (declare lessThanEqualsFloat
    //   (fun (float) (fun (float) (con Prelude.Bool))))
    // (define lessThanEqualsFloat
    //   (lam x (lam y
    //     (builtin lessThanEqualsFloat y x))))
    
    
    // (declare ceil
    //   (fun (float) (integer)))
    // (define ceil
    //   (lam x
    //     (builtin ceil x)))
    
    
    // (declare floor
    //   (fun (float) (integer)))
    // (define floor
    //   (lam x
    //     (builtin floor x)))
    
    
    // (declare maxFloat
    //   (fun (float) (fun (float) (float))))
    // (define maxFloat
    //   (lam x (lam y
    //     (case [Prelude.lessThanFloat x y]
    //       (Prelude.True () y)
    //       (Prelude.False () x)))))
    
    
    // (declare minFloat
    //   (fun (float) (fun (float) (float))))
    // (define minFloat
    //   (lam x (lam y
    //     (case [Prelude.lessThanFloat x y]
    //       (Prelude.True () x)
    //       (Prelude.False () y)))))
    
    
    
    //
    // ByteString Tools
    //
    
    (declare concatenate
      (fun (bytestring) (fun (bytestring) (bytestring))))
    (define concatenate
      (lam x (lam y
        (builtin concatenate x y))))
    
    
    (declare takeByteString
      (fun (integer) (fun (bytestring) (bytestring))))
    (define takeByteString
      (lam n (lam x
        (builtin takeByteString n x))))
    
    
    (declare dropByteString
      (fun (integer) (fun (bytestring) (bytestring))))
    (define dropByteString
      (lam n (lam x
        (builtin dropByteString n x))))
    
    
    (declare sha2_256
      (fun (bytestring) (bytestring)))
    (define sha2_256
      (lam x
        (builtin sha2_256 x)))
    
    
    (declare sha3_256
      (fun (bytestring) (bytestring)))
    (define sha3_256
      (lam x
        (builtin sha3_256 x)))
    
    
    (declare equalsByteString
      (fun (bytestring) (fun (bytestring) (con Prelude.Bool))))
    (define equalsByteString
      (lam x (lam y
        (builtin equalsByteString x y))))
    
    
    
    //
    // Maybe Tools
    //
    
    (data Maybe ((a (type)))
          (Nothing)
          (Just a))
    
    
    (declare maybe
      (forall a (type) (forall b (type)
        (fun b (fun (fun a b) (fun (con Prelude.Maybe a) b))))))
    (define maybe
      (abs a (abs b
        (lam n (lam j (lam m
          (case m
            (Prelude.Nothing () n)
            (Prelude.Just (x) [j x]))))))))
    
    
    (declare isJust
      (forall a (type)
        (fun (con Prelude.Maybe a) (con Prelude.Bool))))
    (define isJust
      (abs a
        (lam m
          (case m
            (Prelude.Nothing ()
              (isa (con Prelude.False)
                   (con Prelude.Bool)))
            (Prelude.Just (x)
              (isa (con Prelude.True)
                   (con Prelude.Bool)))))))
    
    
    (declare isNothing
      (forall a (type)
        (fun (con Prelude.Maybe a) (con Prelude.Bool))))
    (define isNothing
      (abs a
        (lam m
          (case m
            (Prelude.Nothing ()
              (isa (con Prelude.True)
                   (con Prelude.Bool)))
            (Prelude.Just (x)
              (isa (con Prelude.False)
                   (con Prelude.Bool)))))))
    
    
    (declare fromMaybe
      (forall a (type)
        (fun a (fun (con Prelude.Maybe a) a))))
    (define fromMaybe
      (abs a
        (lam n (lam m
          (case m
            (Prelude.Nothing () n)
            (Prelude.Just (x) x))))))

    (declare mapMaybe
      (forall a (type) (forall b (type)
        (fun (fun a b)
             (fun (con Prelude.Maybe a)
                  (con Prelude.Maybe b))))))
    (define mapMaybe
      (abs a (abs b
        (lam f (lam m
          (case m
            (Prelude.Nothing ()
              (isa (con Prelude.Nothing)
                   (con Prelude.Maybe b)))
            (Prelude.Just (x)
              (isa (con Prelude.Just [f x])
                   (con Prelude.Maybe b)))))))))
    
    
    (declare equalsMaybe
      (forall a (type)
        (fun (fun a (fun a (con Prelude.Bool)))
          (fun (con Prelude.Maybe a)
            (fun (con Prelude.Maybe a)
              (con Prelude.Bool))))))
    (define equalsMaybe
      (abs a (lam eq (lam m (lam m'
        (case m
          (Prelude.Nothing ()
            (case m'
              (Prelude.Nothing ()
                (isa (con Prelude.True)
                     (con Prelude.Bool)))
              (Prelude.Just (y)
                (isa (con Prelude.False)
                     (con Prelude.Bool)))))
          (Prelude.Just (x)
            (case m'
              (Prelude.Nothing ()
                (isa (con Prelude.False)
                     (con Prelude.Bool)))
              (Prelude.Just (y) [eq x y])))))))))
    
    
    
    //
    // Either Tools
    //
    
    (data Either ((a (type)) (b (type)))
          (Left a)
          (Right b))
    
    
    (declare either
      (forall a (type) (forall b (type) (forall c (type)
        (fun (fun a c)
             (fun (fun b c)
                  (fun (con Prelude.Either a b) c)))))))
    (define either
      (abs a (abs b (abs c
        (lam f (lam g (lam e
          (case e
            (Prelude.Left (x) [f x])
            (Prelude.Right (y) [g y])))))))))
    
    
    (declare isLeft
      (forall a (type) (forall b (type)
        (fun (con Prelude.Either a b) (con Prelude.Bool)))))
    (define isLeft
      (abs a (abs b
        (lam e
          (case e
            (Prelude.Left (x)
              (isa (con Prelude.True)
                   (con Prelude.Bool)))
            (Prelude.Right (y)
              (isa (con Prelude.False)
                   (con Prelude.Bool))))))))
    
    
    (declare isRight
      (forall a (type) (forall b (type)
        (fun (con Prelude.Either a b) (con Prelude.Bool)))))
    (define isRight
      (abs a (abs b
        (lam e
          (case e
            (Prelude.Left (x)
              (isa (con Prelude.False)
                   (con Prelude.Bool)))
            (Prelude.Right (y)
              (isa (con Prelude.True)
                   (con Prelude.Bool))))))))
    
    
    (declare eitherToMaybe
      (forall a (type) (forall b (type)
        (fun (con Prelude.Either a b)
             (con Prelude.Maybe b)))))
    (define eitherToMaybe
      (abs a (abs b
        (lam e
          (case e
            (Prelude.Left (x)
              (isa (con Prelude.Nothing)
                   (con Prelude.Maybe b)))
            (Prelude.Right (y)
              (isa (con Prelude.Just y)
                   (con Prelude.Maybe b))))))))
    
    
    (declare maybeToEither
      (forall a (type) (forall b (type)
        (fun a
          (fun (con Prelude.Maybe b)
               (con Prelude.Either a b))))))
    (define maybeToEither
      (abs a (abs b
        (lam x (lam m
          (case m
            (Prelude.Nothing ()
              (isa (con Prelude.Left x)
                   (con Prelude.Either a b)))
            (Prelude.Just (y)
              (isa (con Prelude.Right y)
                   (con Prelude.Either a b)))))))))
    
    
    (declare equalsEither
      (forall a (type) (forall b (type)
        (fun (fun a (fun a (con Prelude.Bool)))
          (fun (fun b (fun b (con Prelude.Bool)))
            (fun (con Prelude.Either a b)
              (fun (con Prelude.Either a b)
                (con Prelude.Bool))))))))
    (define equalsEither
      (abs a (abs b (lam eqA (lam eqB (lam e (lam e'
        (case e
          (Prelude.Left (x)
            (case e'
              (Prelude.Left (x') [eqA x x'])
              (Prelude.Right (y')
                (isa (con Prelude.False)
                     (con Prelude.Bool)))))
          (Prelude.Right (y)
            (case e'
              (Prelude.Left (x')
                (isa (con Prelude.False)
                     (con Prelude.Bool)))
              (Prelude.Right (y') [eqB y y'])))))))))))
    
    
    
    //
    // List Tools
    //
    
    (data List ((a (type)))
          (Nil)
          (Cons a (con Prelude.List a)))
    
    
    (declare equalsList
      (forall a (type)
        (fun (fun a (fun a (con Prelude.Bool)))
          (fun (con Prelude.List a)
            (fun (con Prelude.List a)
              (con Prelude.Bool))))))
    (define equalsList
      (abs a (lam eqA (lam xs (lam ys
        (case xs
          (Prelude.Nil ()
            (case ys
              (Prelude.Nil ()
                (isa (con Prelude.True)
                     (con Prelude.Bool)))
              (Prelude.Cons (y ys')
                (isa (con Prelude.False)
                     (con Prelude.Bool)))))
          (Prelude.Cons (x xs')
            (case ys
              (Prelude.Nil ()
                (isa (con Prelude.False)
                     (con Prelude.Bool)))
              (Prelude.Cons (y ys')
                [Prelude.and
                  [eqA x y]
                  [(inst Prelude.equalsList a) eqA xs' ys']]))))))))))